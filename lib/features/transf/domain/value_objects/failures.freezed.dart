// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$TransferFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TransferFailureCopyWith<T, $Res> {
  factory $TransferFailureCopyWith(
          TransferFailure<T> value, $Res Function(TransferFailure<T>) then) =
      _$TransferFailureCopyWithImpl<T, $Res, TransferFailure<T>>;
}

/// @nodoc
class _$TransferFailureCopyWithImpl<T, $Res, $Val extends TransferFailure<T>>
    implements $TransferFailureCopyWith<T, $Res> {
  _$TransferFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InvalidAccountNumberImplCopyWith<T, $Res> {
  factory _$$InvalidAccountNumberImplCopyWith(
          _$InvalidAccountNumberImpl<T> value,
          $Res Function(_$InvalidAccountNumberImpl<T>) then) =
      __$$InvalidAccountNumberImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidAccountNumberImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res,
        _$InvalidAccountNumberImpl<T>>
    implements _$$InvalidAccountNumberImplCopyWith<T, $Res> {
  __$$InvalidAccountNumberImplCopyWithImpl(_$InvalidAccountNumberImpl<T> _value,
      $Res Function(_$InvalidAccountNumberImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidAccountNumberImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidAccountNumberImpl<T> implements InvalidAccountNumber<T> {
  const _$InvalidAccountNumberImpl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.invalidAccountNumber(failedValue: $failedValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidAccountNumberImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidAccountNumberImplCopyWith<T, _$InvalidAccountNumberImpl<T>>
      get copyWith => __$$InvalidAccountNumberImplCopyWithImpl<T,
          _$InvalidAccountNumberImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return invalidAccountNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return invalidAccountNumber?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidAccountNumber != null) {
      return invalidAccountNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return invalidAccountNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return invalidAccountNumber?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidAccountNumber != null) {
      return invalidAccountNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidAccountNumber<T> implements TransferFailure<T> {
  const factory InvalidAccountNumber({required final T failedValue}) =
      _$InvalidAccountNumberImpl<T>;

  T get failedValue;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InvalidAccountNumberImplCopyWith<T, _$InvalidAccountNumberImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountNotFoundImplCopyWith<T, $Res> {
  factory _$$AccountNotFoundImplCopyWith(_$AccountNotFoundImpl<T> value,
          $Res Function(_$AccountNotFoundImpl<T>) then) =
      __$$AccountNotFoundImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$AccountNotFoundImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$AccountNotFoundImpl<T>>
    implements _$$AccountNotFoundImplCopyWith<T, $Res> {
  __$$AccountNotFoundImplCopyWithImpl(_$AccountNotFoundImpl<T> _value,
      $Res Function(_$AccountNotFoundImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$AccountNotFoundImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$AccountNotFoundImpl<T> implements AccountNotFound<T> {
  const _$AccountNotFoundImpl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.accountNotFound(failedValue: $failedValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountNotFoundImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountNotFoundImplCopyWith<T, _$AccountNotFoundImpl<T>> get copyWith =>
      __$$AccountNotFoundImplCopyWithImpl<T, _$AccountNotFoundImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return accountNotFound(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return accountNotFound?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (accountNotFound != null) {
      return accountNotFound(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return accountNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return accountNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (accountNotFound != null) {
      return accountNotFound(this);
    }
    return orElse();
  }
}

abstract class AccountNotFound<T> implements TransferFailure<T> {
  const factory AccountNotFound({required final T failedValue}) =
      _$AccountNotFoundImpl<T>;

  T get failedValue;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountNotFoundImplCopyWith<T, _$AccountNotFoundImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidPhoneNumberImplCopyWith<T, $Res> {
  factory _$$InvalidPhoneNumberImplCopyWith(_$InvalidPhoneNumberImpl<T> value,
          $Res Function(_$InvalidPhoneNumberImpl<T>) then) =
      __$$InvalidPhoneNumberImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidPhoneNumberImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$InvalidPhoneNumberImpl<T>>
    implements _$$InvalidPhoneNumberImplCopyWith<T, $Res> {
  __$$InvalidPhoneNumberImplCopyWithImpl(_$InvalidPhoneNumberImpl<T> _value,
      $Res Function(_$InvalidPhoneNumberImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidPhoneNumberImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidPhoneNumberImpl<T> implements InvalidPhoneNumber<T> {
  const _$InvalidPhoneNumberImpl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.invalidPhoneNumber(failedValue: $failedValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidPhoneNumberImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidPhoneNumberImplCopyWith<T, _$InvalidPhoneNumberImpl<T>>
      get copyWith => __$$InvalidPhoneNumberImplCopyWithImpl<T,
          _$InvalidPhoneNumberImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return invalidPhoneNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return invalidPhoneNumber?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return invalidPhoneNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return invalidPhoneNumber?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidPhoneNumber<T> implements TransferFailure<T> {
  const factory InvalidPhoneNumber({required final T failedValue}) =
      _$InvalidPhoneNumberImpl<T>;

  T get failedValue;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InvalidPhoneNumberImplCopyWith<T, _$InvalidPhoneNumberImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PhoneNumberNotFoundImplCopyWith<T, $Res> {
  factory _$$PhoneNumberNotFoundImplCopyWith(_$PhoneNumberNotFoundImpl<T> value,
          $Res Function(_$PhoneNumberNotFoundImpl<T>) then) =
      __$$PhoneNumberNotFoundImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$PhoneNumberNotFoundImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$PhoneNumberNotFoundImpl<T>>
    implements _$$PhoneNumberNotFoundImplCopyWith<T, $Res> {
  __$$PhoneNumberNotFoundImplCopyWithImpl(_$PhoneNumberNotFoundImpl<T> _value,
      $Res Function(_$PhoneNumberNotFoundImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$PhoneNumberNotFoundImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$PhoneNumberNotFoundImpl<T> implements PhoneNumberNotFound<T> {
  const _$PhoneNumberNotFoundImpl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.phoneNumberNotFound(failedValue: $failedValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PhoneNumberNotFoundImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PhoneNumberNotFoundImplCopyWith<T, _$PhoneNumberNotFoundImpl<T>>
      get copyWith => __$$PhoneNumberNotFoundImplCopyWithImpl<T,
          _$PhoneNumberNotFoundImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return phoneNumberNotFound(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return phoneNumberNotFound?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (phoneNumberNotFound != null) {
      return phoneNumberNotFound(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return phoneNumberNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return phoneNumberNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (phoneNumberNotFound != null) {
      return phoneNumberNotFound(this);
    }
    return orElse();
  }
}

abstract class PhoneNumberNotFound<T> implements TransferFailure<T> {
  const factory PhoneNumberNotFound({required final T failedValue}) =
      _$PhoneNumberNotFoundImpl<T>;

  T get failedValue;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PhoneNumberNotFoundImplCopyWith<T, _$PhoneNumberNotFoundImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WalletAccountNotFoundImplCopyWith<T, $Res> {
  factory _$$WalletAccountNotFoundImplCopyWith(
          _$WalletAccountNotFoundImpl<T> value,
          $Res Function(_$WalletAccountNotFoundImpl<T>) then) =
      __$$WalletAccountNotFoundImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$WalletAccountNotFoundImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res,
        _$WalletAccountNotFoundImpl<T>>
    implements _$$WalletAccountNotFoundImplCopyWith<T, $Res> {
  __$$WalletAccountNotFoundImplCopyWithImpl(
      _$WalletAccountNotFoundImpl<T> _value,
      $Res Function(_$WalletAccountNotFoundImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$WalletAccountNotFoundImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$WalletAccountNotFoundImpl<T> implements WalletAccountNotFound<T> {
  const _$WalletAccountNotFoundImpl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.walletAccountNotFound(failedValue: $failedValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletAccountNotFoundImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WalletAccountNotFoundImplCopyWith<T, _$WalletAccountNotFoundImpl<T>>
      get copyWith => __$$WalletAccountNotFoundImplCopyWithImpl<T,
          _$WalletAccountNotFoundImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return walletAccountNotFound(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return walletAccountNotFound?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (walletAccountNotFound != null) {
      return walletAccountNotFound(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return walletAccountNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return walletAccountNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (walletAccountNotFound != null) {
      return walletAccountNotFound(this);
    }
    return orElse();
  }
}

abstract class WalletAccountNotFound<T> implements TransferFailure<T> {
  const factory WalletAccountNotFound({required final T failedValue}) =
      _$WalletAccountNotFoundImpl<T>;

  T get failedValue;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WalletAccountNotFoundImplCopyWith<T, _$WalletAccountNotFoundImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidWalletAccountImplCopyWith<T, $Res> {
  factory _$$InvalidWalletAccountImplCopyWith(
          _$InvalidWalletAccountImpl<T> value,
          $Res Function(_$InvalidWalletAccountImpl<T>) then) =
      __$$InvalidWalletAccountImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidWalletAccountImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res,
        _$InvalidWalletAccountImpl<T>>
    implements _$$InvalidWalletAccountImplCopyWith<T, $Res> {
  __$$InvalidWalletAccountImplCopyWithImpl(_$InvalidWalletAccountImpl<T> _value,
      $Res Function(_$InvalidWalletAccountImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidWalletAccountImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidWalletAccountImpl<T> implements InvalidWalletAccount<T> {
  const _$InvalidWalletAccountImpl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.invalidWalletAccount(failedValue: $failedValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidWalletAccountImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidWalletAccountImplCopyWith<T, _$InvalidWalletAccountImpl<T>>
      get copyWith => __$$InvalidWalletAccountImplCopyWithImpl<T,
          _$InvalidWalletAccountImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return invalidWalletAccount(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return invalidWalletAccount?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidWalletAccount != null) {
      return invalidWalletAccount(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return invalidWalletAccount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return invalidWalletAccount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidWalletAccount != null) {
      return invalidWalletAccount(this);
    }
    return orElse();
  }
}

abstract class InvalidWalletAccount<T> implements TransferFailure<T> {
  const factory InvalidWalletAccount({required final T failedValue}) =
      _$InvalidWalletAccountImpl<T>;

  T get failedValue;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InvalidWalletAccountImplCopyWith<T, _$InvalidWalletAccountImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidAmountImplCopyWith<T, $Res> {
  factory _$$InvalidAmountImplCopyWith(_$InvalidAmountImpl<T> value,
          $Res Function(_$InvalidAmountImpl<T>) then) =
      __$$InvalidAmountImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidAmountImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$InvalidAmountImpl<T>>
    implements _$$InvalidAmountImplCopyWith<T, $Res> {
  __$$InvalidAmountImplCopyWithImpl(_$InvalidAmountImpl<T> _value,
      $Res Function(_$InvalidAmountImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidAmountImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidAmountImpl<T> implements InvalidAmount<T> {
  const _$InvalidAmountImpl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'TransferFailure<$T>.invalidAmount(failedValue: $failedValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidAmountImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidAmountImplCopyWith<T, _$InvalidAmountImpl<T>> get copyWith =>
      __$$InvalidAmountImplCopyWithImpl<T, _$InvalidAmountImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return invalidAmount(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return invalidAmount?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidAmount != null) {
      return invalidAmount(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return invalidAmount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return invalidAmount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidAmount != null) {
      return invalidAmount(this);
    }
    return orElse();
  }
}

abstract class InvalidAmount<T> implements TransferFailure<T> {
  const factory InvalidAmount({required final T failedValue}) =
      _$InvalidAmountImpl<T>;

  T get failedValue;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InvalidAmountImplCopyWith<T, _$InvalidAmountImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InsufficientFundsImplCopyWith<T, $Res> {
  factory _$$InsufficientFundsImplCopyWith(_$InsufficientFundsImpl<T> value,
          $Res Function(_$InsufficientFundsImpl<T>) then) =
      __$$InsufficientFundsImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue, double available});
}

/// @nodoc
class __$$InsufficientFundsImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$InsufficientFundsImpl<T>>
    implements _$$InsufficientFundsImplCopyWith<T, $Res> {
  __$$InsufficientFundsImplCopyWithImpl(_$InsufficientFundsImpl<T> _value,
      $Res Function(_$InsufficientFundsImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? available = null,
  }) {
    return _then(_$InsufficientFundsImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      available: null == available
          ? _value.available
          : available // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$InsufficientFundsImpl<T> implements InsufficientFunds<T> {
  const _$InsufficientFundsImpl(
      {required this.failedValue, required this.available});

  @override
  final T failedValue;
  @override
  final double available;

  @override
  String toString() {
    return 'TransferFailure<$T>.insufficientFunds(failedValue: $failedValue, available: $available)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsufficientFundsImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            (identical(other.available, available) ||
                other.available == available));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue), available);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InsufficientFundsImplCopyWith<T, _$InsufficientFundsImpl<T>>
      get copyWith =>
          __$$InsufficientFundsImplCopyWithImpl<T, _$InsufficientFundsImpl<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return insufficientFunds(failedValue, available);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return insufficientFunds?.call(failedValue, available);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(failedValue, available);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return insufficientFunds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return insufficientFunds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(this);
    }
    return orElse();
  }
}

abstract class InsufficientFunds<T> implements TransferFailure<T> {
  const factory InsufficientFunds(
      {required final T failedValue,
      required final double available}) = _$InsufficientFundsImpl<T>;

  T get failedValue;
  double get available;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InsufficientFundsImplCopyWith<T, _$InsufficientFundsImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExceedsTransferLimitImplCopyWith<T, $Res> {
  factory _$$ExceedsTransferLimitImplCopyWith(
          _$ExceedsTransferLimitImpl<T> value,
          $Res Function(_$ExceedsTransferLimitImpl<T>) then) =
      __$$ExceedsTransferLimitImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue, double limit});
}

/// @nodoc
class __$$ExceedsTransferLimitImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res,
        _$ExceedsTransferLimitImpl<T>>
    implements _$$ExceedsTransferLimitImplCopyWith<T, $Res> {
  __$$ExceedsTransferLimitImplCopyWithImpl(_$ExceedsTransferLimitImpl<T> _value,
      $Res Function(_$ExceedsTransferLimitImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? limit = null,
  }) {
    return _then(_$ExceedsTransferLimitImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$ExceedsTransferLimitImpl<T> implements ExceedsTransferLimit<T> {
  const _$ExceedsTransferLimitImpl(
      {required this.failedValue, required this.limit});

  @override
  final T failedValue;
  @override
  final double limit;

  @override
  String toString() {
    return 'TransferFailure<$T>.exceedsTransferLimit(failedValue: $failedValue, limit: $limit)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExceedsTransferLimitImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            (identical(other.limit, limit) || other.limit == limit));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue), limit);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExceedsTransferLimitImplCopyWith<T, _$ExceedsTransferLimitImpl<T>>
      get copyWith => __$$ExceedsTransferLimitImplCopyWithImpl<T,
          _$ExceedsTransferLimitImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return exceedsTransferLimit(failedValue, limit);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return exceedsTransferLimit?.call(failedValue, limit);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (exceedsTransferLimit != null) {
      return exceedsTransferLimit(failedValue, limit);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return exceedsTransferLimit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return exceedsTransferLimit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (exceedsTransferLimit != null) {
      return exceedsTransferLimit(this);
    }
    return orElse();
  }
}

abstract class ExceedsTransferLimit<T> implements TransferFailure<T> {
  const factory ExceedsTransferLimit(
      {required final T failedValue,
      required final double limit}) = _$ExceedsTransferLimitImpl<T>;

  T get failedValue;
  double get limit;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExceedsTransferLimitImplCopyWith<T, _$ExceedsTransferLimitImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BelowMinimumAmountImplCopyWith<T, $Res> {
  factory _$$BelowMinimumAmountImplCopyWith(_$BelowMinimumAmountImpl<T> value,
          $Res Function(_$BelowMinimumAmountImpl<T>) then) =
      __$$BelowMinimumAmountImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue, double minimum});
}

/// @nodoc
class __$$BelowMinimumAmountImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$BelowMinimumAmountImpl<T>>
    implements _$$BelowMinimumAmountImplCopyWith<T, $Res> {
  __$$BelowMinimumAmountImplCopyWithImpl(_$BelowMinimumAmountImpl<T> _value,
      $Res Function(_$BelowMinimumAmountImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? minimum = null,
  }) {
    return _then(_$BelowMinimumAmountImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      minimum: null == minimum
          ? _value.minimum
          : minimum // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$BelowMinimumAmountImpl<T> implements BelowMinimumAmount<T> {
  const _$BelowMinimumAmountImpl(
      {required this.failedValue, required this.minimum});

  @override
  final T failedValue;
  @override
  final double minimum;

  @override
  String toString() {
    return 'TransferFailure<$T>.belowMinimumAmount(failedValue: $failedValue, minimum: $minimum)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BelowMinimumAmountImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            (identical(other.minimum, minimum) || other.minimum == minimum));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue), minimum);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BelowMinimumAmountImplCopyWith<T, _$BelowMinimumAmountImpl<T>>
      get copyWith => __$$BelowMinimumAmountImplCopyWithImpl<T,
          _$BelowMinimumAmountImpl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return belowMinimumAmount(failedValue, minimum);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return belowMinimumAmount?.call(failedValue, minimum);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (belowMinimumAmount != null) {
      return belowMinimumAmount(failedValue, minimum);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return belowMinimumAmount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return belowMinimumAmount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (belowMinimumAmount != null) {
      return belowMinimumAmount(this);
    }
    return orElse();
  }
}

abstract class BelowMinimumAmount<T> implements TransferFailure<T> {
  const factory BelowMinimumAmount(
      {required final T failedValue,
      required final double minimum}) = _$BelowMinimumAmountImpl<T>;

  T get failedValue;
  double get minimum;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BelowMinimumAmountImplCopyWith<T, _$BelowMinimumAmountImpl<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ServerErrorImplCopyWith<T, $Res> {
  factory _$$ServerErrorImplCopyWith(_$ServerErrorImpl<T> value,
          $Res Function(_$ServerErrorImpl<T>) then) =
      __$$ServerErrorImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ServerErrorImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$ServerErrorImpl<T>>
    implements _$$ServerErrorImplCopyWith<T, $Res> {
  __$$ServerErrorImplCopyWithImpl(
      _$ServerErrorImpl<T> _value, $Res Function(_$ServerErrorImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ServerErrorImpl<T>(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ServerErrorImpl<T> implements ServerError<T> {
  const _$ServerErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'TransferFailure<$T>.serverError(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ServerErrorImpl<T> &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ServerErrorImplCopyWith<T, _$ServerErrorImpl<T>> get copyWith =>
      __$$ServerErrorImplCopyWithImpl<T, _$ServerErrorImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return serverError(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return serverError?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError<T> implements TransferFailure<T> {
  const factory ServerError({required final String message}) =
      _$ServerErrorImpl<T>;

  String get message;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ServerErrorImplCopyWith<T, _$ServerErrorImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NetworkErrorImplCopyWith<T, $Res> {
  factory _$$NetworkErrorImplCopyWith(_$NetworkErrorImpl<T> value,
          $Res Function(_$NetworkErrorImpl<T>) then) =
      __$$NetworkErrorImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$NetworkErrorImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$NetworkErrorImpl<T>>
    implements _$$NetworkErrorImplCopyWith<T, $Res> {
  __$$NetworkErrorImplCopyWithImpl(
      _$NetworkErrorImpl<T> _value, $Res Function(_$NetworkErrorImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$NetworkErrorImpl<T> implements NetworkError<T> {
  const _$NetworkErrorImpl();

  @override
  String toString() {
    return 'TransferFailure<$T>.networkError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NetworkErrorImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return networkError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return networkError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return networkError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return networkError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError(this);
    }
    return orElse();
  }
}

abstract class NetworkError<T> implements TransferFailure<T> {
  const factory NetworkError() = _$NetworkErrorImpl<T>;
}

/// @nodoc
abstract class _$$UnexpectedImplCopyWith<T, $Res> {
  factory _$$UnexpectedImplCopyWith(
          _$UnexpectedImpl<T> value, $Res Function(_$UnexpectedImpl<T>) then) =
      __$$UnexpectedImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$UnexpectedImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$UnexpectedImpl<T>>
    implements _$$UnexpectedImplCopyWith<T, $Res> {
  __$$UnexpectedImplCopyWithImpl(
      _$UnexpectedImpl<T> _value, $Res Function(_$UnexpectedImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UnexpectedImpl<T> implements Unexpected<T> {
  const _$UnexpectedImpl();

  @override
  String toString() {
    return 'TransferFailure<$T>.unexpected()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnexpectedImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class Unexpected<T> implements TransferFailure<T> {
  const factory Unexpected() = _$UnexpectedImpl<T>;
}

/// @nodoc
abstract class _$$TransactionNotFoundImplCopyWith<T, $Res> {
  factory _$$TransactionNotFoundImplCopyWith(_$TransactionNotFoundImpl<T> value,
          $Res Function(_$TransactionNotFoundImpl<T>) then) =
      __$$TransactionNotFoundImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$TransactionNotFoundImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$TransactionNotFoundImpl<T>>
    implements _$$TransactionNotFoundImplCopyWith<T, $Res> {
  __$$TransactionNotFoundImplCopyWithImpl(_$TransactionNotFoundImpl<T> _value,
      $Res Function(_$TransactionNotFoundImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$TransactionNotFoundImpl<T> implements TransactionNotFound<T> {
  const _$TransactionNotFoundImpl();

  @override
  String toString() {
    return 'TransferFailure<$T>.transactionNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TransactionNotFoundImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return transactionNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return transactionNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (transactionNotFound != null) {
      return transactionNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return transactionNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return transactionNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (transactionNotFound != null) {
      return transactionNotFound(this);
    }
    return orElse();
  }
}

abstract class TransactionNotFound<T> implements TransferFailure<T> {
  const factory TransactionNotFound() = _$TransactionNotFoundImpl<T>;
}

/// @nodoc
abstract class _$$UnauthenticatedImplCopyWith<T, $Res> {
  factory _$$UnauthenticatedImplCopyWith(_$UnauthenticatedImpl<T> value,
          $Res Function(_$UnauthenticatedImpl<T>) then) =
      __$$UnauthenticatedImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$UnauthenticatedImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$UnauthenticatedImpl<T>>
    implements _$$UnauthenticatedImplCopyWith<T, $Res> {
  __$$UnauthenticatedImplCopyWithImpl(_$UnauthenticatedImpl<T> _value,
      $Res Function(_$UnauthenticatedImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UnauthenticatedImpl<T> implements Unauthenticated<T> {
  const _$UnauthenticatedImpl();

  @override
  String toString() {
    return 'TransferFailure<$T>.unauthenticated()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnauthenticatedImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return unauthenticated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return unauthenticated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (unauthenticated != null) {
      return unauthenticated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return unauthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return unauthenticated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (unauthenticated != null) {
      return unauthenticated(this);
    }
    return orElse();
  }
}

abstract class Unauthenticated<T> implements TransferFailure<T> {
  const factory Unauthenticated() = _$UnauthenticatedImpl<T>;
}

/// @nodoc
abstract class _$$UnauthorizedImplCopyWith<T, $Res> {
  factory _$$UnauthorizedImplCopyWith(_$UnauthorizedImpl<T> value,
          $Res Function(_$UnauthorizedImpl<T>) then) =
      __$$UnauthorizedImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$UnauthorizedImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$UnauthorizedImpl<T>>
    implements _$$UnauthorizedImplCopyWith<T, $Res> {
  __$$UnauthorizedImplCopyWithImpl(
      _$UnauthorizedImpl<T> _value, $Res Function(_$UnauthorizedImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UnauthorizedImpl<T> implements Unauthorized<T> {
  const _$UnauthorizedImpl();

  @override
  String toString() {
    return 'TransferFailure<$T>.unauthorized()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnauthorizedImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return unauthorized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return unauthorized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return unauthorized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return unauthorized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized(this);
    }
    return orElse();
  }
}

abstract class Unauthorized<T> implements TransferFailure<T> {
  const factory Unauthorized() = _$UnauthorizedImpl<T>;
}

/// @nodoc
abstract class _$$InvalidInputImplCopyWith<T, $Res> {
  factory _$$InvalidInputImplCopyWith(_$InvalidInputImpl<T> value,
          $Res Function(_$InvalidInputImpl<T>) then) =
      __$$InvalidInputImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue, String message});
}

/// @nodoc
class __$$InvalidInputImplCopyWithImpl<T, $Res>
    extends _$TransferFailureCopyWithImpl<T, $Res, _$InvalidInputImpl<T>>
    implements _$$InvalidInputImplCopyWith<T, $Res> {
  __$$InvalidInputImplCopyWithImpl(
      _$InvalidInputImpl<T> _value, $Res Function(_$InvalidInputImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? message = null,
  }) {
    return _then(_$InvalidInputImpl<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidInputImpl<T> implements InvalidInput<T> {
  const _$InvalidInputImpl({required this.failedValue, required this.message});

  @override
  final T failedValue;
  @override
  final String message;

  @override
  String toString() {
    return 'TransferFailure<$T>.invalidInput(failedValue: $failedValue, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidInputImpl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue), message);

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidInputImplCopyWith<T, _$InvalidInputImpl<T>> get copyWith =>
      __$$InvalidInputImplCopyWithImpl<T, _$InvalidInputImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidAccountNumber,
    required TResult Function(T failedValue) accountNotFound,
    required TResult Function(T failedValue) invalidPhoneNumber,
    required TResult Function(T failedValue) phoneNumberNotFound,
    required TResult Function(T failedValue) walletAccountNotFound,
    required TResult Function(T failedValue) invalidWalletAccount,
    required TResult Function(T failedValue) invalidAmount,
    required TResult Function(T failedValue, double available)
        insufficientFunds,
    required TResult Function(T failedValue, double limit) exceedsTransferLimit,
    required TResult Function(T failedValue, double minimum) belowMinimumAmount,
    required TResult Function(String message) serverError,
    required TResult Function() networkError,
    required TResult Function() unexpected,
    required TResult Function() transactionNotFound,
    required TResult Function() unauthenticated,
    required TResult Function() unauthorized,
    required TResult Function(T failedValue, String message) invalidInput,
  }) {
    return invalidInput(failedValue, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? invalidAccountNumber,
    TResult? Function(T failedValue)? accountNotFound,
    TResult? Function(T failedValue)? invalidPhoneNumber,
    TResult? Function(T failedValue)? phoneNumberNotFound,
    TResult? Function(T failedValue)? walletAccountNotFound,
    TResult? Function(T failedValue)? invalidWalletAccount,
    TResult? Function(T failedValue)? invalidAmount,
    TResult? Function(T failedValue, double available)? insufficientFunds,
    TResult? Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult? Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult? Function(String message)? serverError,
    TResult? Function()? networkError,
    TResult? Function()? unexpected,
    TResult? Function()? transactionNotFound,
    TResult? Function()? unauthenticated,
    TResult? Function()? unauthorized,
    TResult? Function(T failedValue, String message)? invalidInput,
  }) {
    return invalidInput?.call(failedValue, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidAccountNumber,
    TResult Function(T failedValue)? accountNotFound,
    TResult Function(T failedValue)? invalidPhoneNumber,
    TResult Function(T failedValue)? phoneNumberNotFound,
    TResult Function(T failedValue)? walletAccountNotFound,
    TResult Function(T failedValue)? invalidWalletAccount,
    TResult Function(T failedValue)? invalidAmount,
    TResult Function(T failedValue, double available)? insufficientFunds,
    TResult Function(T failedValue, double limit)? exceedsTransferLimit,
    TResult Function(T failedValue, double minimum)? belowMinimumAmount,
    TResult Function(String message)? serverError,
    TResult Function()? networkError,
    TResult Function()? unexpected,
    TResult Function()? transactionNotFound,
    TResult Function()? unauthenticated,
    TResult Function()? unauthorized,
    TResult Function(T failedValue, String message)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidInput != null) {
      return invalidInput(failedValue, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAccountNumber<T> value)
        invalidAccountNumber,
    required TResult Function(AccountNotFound<T> value) accountNotFound,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(PhoneNumberNotFound<T> value) phoneNumberNotFound,
    required TResult Function(WalletAccountNotFound<T> value)
        walletAccountNotFound,
    required TResult Function(InvalidWalletAccount<T> value)
        invalidWalletAccount,
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InsufficientFunds<T> value) insufficientFunds,
    required TResult Function(ExceedsTransferLimit<T> value)
        exceedsTransferLimit,
    required TResult Function(BelowMinimumAmount<T> value) belowMinimumAmount,
    required TResult Function(ServerError<T> value) serverError,
    required TResult Function(NetworkError<T> value) networkError,
    required TResult Function(Unexpected<T> value) unexpected,
    required TResult Function(TransactionNotFound<T> value) transactionNotFound,
    required TResult Function(Unauthenticated<T> value) unauthenticated,
    required TResult Function(Unauthorized<T> value) unauthorized,
    required TResult Function(InvalidInput<T> value) invalidInput,
  }) {
    return invalidInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult? Function(AccountNotFound<T> value)? accountNotFound,
    TResult? Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult? Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult? Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult? Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult? Function(InvalidAmount<T> value)? invalidAmount,
    TResult? Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult? Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult? Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult? Function(ServerError<T> value)? serverError,
    TResult? Function(NetworkError<T> value)? networkError,
    TResult? Function(Unexpected<T> value)? unexpected,
    TResult? Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult? Function(Unauthenticated<T> value)? unauthenticated,
    TResult? Function(Unauthorized<T> value)? unauthorized,
    TResult? Function(InvalidInput<T> value)? invalidInput,
  }) {
    return invalidInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAccountNumber<T> value)? invalidAccountNumber,
    TResult Function(AccountNotFound<T> value)? accountNotFound,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(PhoneNumberNotFound<T> value)? phoneNumberNotFound,
    TResult Function(WalletAccountNotFound<T> value)? walletAccountNotFound,
    TResult Function(InvalidWalletAccount<T> value)? invalidWalletAccount,
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InsufficientFunds<T> value)? insufficientFunds,
    TResult Function(ExceedsTransferLimit<T> value)? exceedsTransferLimit,
    TResult Function(BelowMinimumAmount<T> value)? belowMinimumAmount,
    TResult Function(ServerError<T> value)? serverError,
    TResult Function(NetworkError<T> value)? networkError,
    TResult Function(Unexpected<T> value)? unexpected,
    TResult Function(TransactionNotFound<T> value)? transactionNotFound,
    TResult Function(Unauthenticated<T> value)? unauthenticated,
    TResult Function(Unauthorized<T> value)? unauthorized,
    TResult Function(InvalidInput<T> value)? invalidInput,
    required TResult orElse(),
  }) {
    if (invalidInput != null) {
      return invalidInput(this);
    }
    return orElse();
  }
}

abstract class InvalidInput<T> implements TransferFailure<T> {
  const factory InvalidInput(
      {required final T failedValue,
      required final String message}) = _$InvalidInputImpl<T>;

  T get failedValue;
  String get message;

  /// Create a copy of TransferFailure
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InvalidInputImplCopyWith<T, _$InvalidInputImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
